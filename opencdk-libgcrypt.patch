--- opencdk-0.5.1/src/seskey.c.orig	2003-06-21 15:24:51.000000000 +0200
+++ opencdk-0.5.1/src/seskey.c	2003-08-03 14:41:27.000000000 +0200
@@ -141,9 +141,9 @@
     n += dek->keylen;
     frame[n++] = chksum >> 8;
     frame[n++] = chksum;
-    rc = gcry_mpi_scan (&a, GCRYMPI_FMT_USG, frame, &nframe);
+    rc = gcry_mpi_scan (&a, GCRYMPI_FMT_USG, frame, nframe, &nframe);
     if (rc)
-        rc = CDK_Gcry_Error;
+        rc += CDK_Gcry_Error_Base;
     cdk_free (frame);
     if( !rc ) {
         rc = cdk_sesskey_new( r_esk );
@@ -170,9 +170,9 @@
         return CDK_Inv_Value;
     
     nframe = sizeof frame-1;
-    rc = gcry_mpi_print (GCRYMPI_FMT_USG, frame, &nframe, esk->a);
+    rc = gcry_mpi_print (GCRYMPI_FMT_USG, frame, nframe, &nframe, esk->a);
     if( rc )
-        return CDK_Gcry_Error;
+        return CDK_Gcry_Error_Base + rc;
     dek = cdk_salloc( sizeof *dek, 1 );
     if( !dek )
         return CDK_Out_Of_Core;
--- opencdk-0.5.1/src/keygen.c.orig	2003-06-21 15:40:41.000000000 +0200
+++ opencdk-0.5.1/src/keygen.c	2003-08-03 14:48:48.000000000 +0200
@@ -296,7 +296,7 @@
     if( list )
         *r_resarr = gcry_sexp_nth_mpi( list, 1, 0 );
     gcry_sexp_release( list );
-    return list? 0 : CDK_Gcry_Error;
+    return list? 0 : CDK_General_Error;
 }
 
   
@@ -466,7 +466,7 @@
         nbytes = a->bytes;
         a->data[0] = nbits >> 8;
         a->data[1] = nbits;
-        rc = gcry_mpi_print( GCRYMPI_FMT_USG, a->data+2, &nbytes, resarr[i] );
+        rc = gcry_mpi_print( GCRYMPI_FMT_USG, a->data+2, nbytes, &nbytes, resarr[i] );
         if( rc )
             break;
         if( pk )
--- opencdk-0.5.1/src/main.c.orig	2003-06-21 11:14:32.000000000 +0200
+++ opencdk-0.5.1/src/main.c	2003-08-03 14:33:14.000000000 +0200
@@ -76,7 +76,6 @@
     case CDK_Inv_Packet:       return "Invalid packet";
     case CDK_Inv_Algo:         return "Invalid algorithm";
     case CDK_Not_Implemented:  return "This is not implemented yet";
-    case CDK_Gcry_Error:       return gcry_strerror (gcry_errno ());
     case CDK_Armor_Error:      return "ASCII armor error";
     case CDK_Armor_CRC_Error:  return "ASCII armored damaged (CRC error)";
     case CDK_MPI_Error:        return "Invalid or missformed MPI";
@@ -94,7 +93,11 @@
     case CDK_Inv_Packet_Ver:   return "Invalid version for packet";
     case CDK_Too_Short:        return "Buffer or object is too short";
     case CDK_Unusable_Key:     return "Unusable public key";
-    default:                   sprintf (buf, "ec=%d", ec); return buf;
+    default:
+	if (ec >= CDK_Gcry_Error_Base && ec < (CDK_Gcry_Error_Base + GPG_ERR_CODE_DIM))
+			       return gcry_strerror (ec - CDK_Gcry_Error_Base);
+	else
+			       sprintf (buf, "ec=%d", ec); return buf;
     }
     return NULL;
 }
--- opencdk-0.5.1/src/sign.c.orig	2003-06-21 15:37:58.000000000 +0200
+++ opencdk-0.5.1/src/sign.c	2003-08-03 14:40:39.000000000 +0200
@@ -401,7 +401,7 @@
     md = cdk_md_open( digest_algo, 0 );
     if( !md ) {
         cdk_sklist_release( list );
-        return CDK_Gcry_Error;
+        return CDK_General_Error;
     }
 
     s = _cdk_armor_get_lineend( );
--- opencdk-0.5.1/src/types.h.orig	2003-06-21 15:45:36.000000000 +0200
+++ opencdk-0.5.1/src/types.h	2003-08-03 13:19:08.000000000 +0200
@@ -51,8 +51,4 @@
 typedef struct cdk_verify_result_s *_cdk_verify_result_t;
 
 
-/* kludge until we support this in the lib */
-typedef GCRY_MPI gcry_mpi_t;
-typedef GCRY_SEXP gcry_sexp_t;
-
 #endif /* CDK_TYPES_H */
--- opencdk-0.5.1/src/pubkey.c.orig	2003-06-21 15:23:24.000000000 +0200
+++ opencdk-0.5.1/src/pubkey.c	2003-08-03 14:47:05.000000000 +0200
@@ -44,8 +44,8 @@
         return NULL;
     for( i = 0; i < ncount; i++ ) {
         nbytes = m[i]->bytes + 2;
-        if( gcry_mpi_scan( &d[i], GCRYMPI_FMT_PGP, m[i]->data, &nbytes ) ) {
-            rc = CDK_Gcry_Error;
+        if( gcry_mpi_scan( &d[i], GCRYMPI_FMT_PGP, m[i]->data, nbytes, &nbytes ) ) {
+            rc += CDK_Gcry_Error_Base;
             break;
 	}
     }
@@ -81,21 +81,21 @@
         rc = CDK_MPI_Error;
     if( !rc && is_RSA( sk->pubkey_algo ) ) {
         fmt = "(private-key(openpgp-rsa(n%m)(e%m)(d%m)(p%m)(q%m)(u%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, mpk[0], mpk[1],
-                             msk[0], msk[1], msk[2], msk[3] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, mpk[0], mpk[1],
+                                   msk[0], msk[1], msk[2], msk[3] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else if( !rc && is_ELG( sk->pubkey_algo ) ) {
         fmt = "(private-key(openpgp-elg(p%m)(g%m)(y%m)(x%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, mpk[0], mpk[1],
-                             mpk[2], msk[0] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, mpk[0], mpk[1],
+                                   mpk[2], msk[0] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else if( !rc && is_DSA( sk->pubkey_algo ) ) {
         fmt = "(private-key(openpgp-dsa(p%m)(q%m)(g%m)(y%m)(x%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, mpk[0], mpk[1], mpk[2],
-                             mpk[3], msk[0] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, mpk[0], mpk[1], mpk[2],
+                                   mpk[3], msk[0] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else
         rc = CDK_Inv_Algo;
@@ -125,18 +125,18 @@
         return CDK_MPI_Error;
     if( is_RSA( pk->pubkey_algo ) ) {
         fmt = "(public-key(openpgp-rsa(n%m)(e%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else if( is_ELG( pk->pubkey_algo ) ) {
         fmt = "(public-key(openpgp-elg(p%m)(g%m)(y%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1], m[2] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1], m[2] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else if( is_DSA( pk->pubkey_algo ) ) {
         fmt = "(public-key(openpgp-dsa(p%m)(q%m)(g%m)(y%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1], m[2], m[3] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1], m[2], m[3] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else
         rc = CDK_Inv_Algo;
@@ -154,8 +154,8 @@
 
     if( !r_sexp || !esk )
         return CDK_Inv_Value;
-    if( gcry_sexp_build( &sexp, NULL, "%m", esk ) )
-        rc = CDK_Gcry_Error;
+    if( (rc = gcry_sexp_build( &sexp, NULL, "%m", esk )) )
+        rc += CDK_Gcry_Error_Base;
     *r_sexp = sexp;
     return rc;
 }
@@ -174,10 +174,10 @@
     nbytes = mdlen ? mdlen : cdk_md_get_algo_dlen( algo );
     if( !nbytes )
         return CDK_Inv_Algo;
-    if( gcry_mpi_scan( &m, GCRYMPI_FMT_USG, md, &nbytes ) )
-        return CDK_Gcry_Error;
-    if( gcry_sexp_build( &sexp, NULL, "%m", m ) )
-        rc = CDK_Gcry_Error;
+    if( (rc = gcry_mpi_scan( &m, GCRYMPI_FMT_USG, md, nbytes, &nbytes )) )
+        return CDK_Gcry_Error_Base + rc;
+    if( (rc = gcry_sexp_build( &sexp, NULL, "%m", m )) )
+        rc += CDK_Gcry_Error_Base;
     if( !rc )
         *r_md = sexp;
     gcry_mpi_release( m );
@@ -199,11 +199,11 @@
 
     list = gcry_sexp_find_token( sexp, val, 0 );
     if( !list )
-        return CDK_Gcry_Error;
+        return CDK_General_Error;
     m = gcry_sexp_nth_mpi( list, 1, 0 );
     if( !m ) {
         gcry_sexp_release( list );
-        return CDK_Gcry_Error;
+        return CDK_General_Error;
     }
     nbits = gcry_mpi_get_nbits( m );
     nbytes = (nbits + 7) / 8;
@@ -214,11 +214,11 @@
     }
     buf->data[0] = nbits >> 8;
     buf->data[1] = nbits;
-    if( gcry_mpi_print( GCRYMPI_FMT_USG, NULL, &nbytes, m ) )
-        rc = CDK_Gcry_Error;
+    if( (rc = gcry_mpi_print( GCRYMPI_FMT_USG, NULL, nbytes, &nbytes, m )) )
+        rc += CDK_Gcry_Error_Base;
     else
-        if( gcry_mpi_print( GCRYMPI_FMT_USG, buf->data + 2, &nbytes, m ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_mpi_print( GCRYMPI_FMT_USG, buf->data + 2, nbytes, &nbytes, m )) )
+            rc += CDK_Gcry_Error_Base;
     if( !rc ) {
         buf->bytes = nbytes;
         buf->bits = nbits;
@@ -270,18 +270,18 @@
         return CDK_MPI_Error;
     if( is_RSA( sig->pubkey_algo ) ) {
         fmt = "(sig-val(openpgp-rsa(s%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, m[0] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, m[0] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else if( is_ELG( sig->pubkey_algo ) ) {
         fmt = "(sig-val(openpgp-elg(r%m)(s%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else if( is_DSA( sig->pubkey_algo ) ) {
         fmt = "(sig-val(openpgp-dsa(r%m)(s%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else
         rc = CDK_Inv_Algo;
@@ -329,13 +329,13 @@
         return CDK_MPI_Error;
     if( is_RSA( enc->pubkey_algo ) ) {
         fmt = "(enc-val(openpgp-rsa((a%m))))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, m[0] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, m[0] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else if( is_ELG( enc->pubkey_algo ) ) {
         fmt = "(enc-val(openpgp-elg((a%m)(b%m))))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else
         rc = CDK_Inv_Algo;
@@ -415,8 +415,8 @@
     rc = seckey_to_sexp( &s_skey, sk );
     if( !rc )
         rc = pubenc_to_sexp( &s_data, pke );
-    if( !rc && gcry_pk_decrypt( &s_plain, s_data, s_skey ) )
-        rc = CDK_Gcry_Error;
+    if( !rc && (rc = gcry_pk_decrypt( &s_plain, s_data, s_skey )) )
+        rc += CDK_Gcry_Error_Base;
     if( !rc ) {
         rc = cdk_sesskey_new( r_sk );
         if( !rc )
@@ -462,8 +462,8 @@
         rc = seckey_to_sexp( &s_skey, sk );
     if( !rc )
         rc = digest_to_sexp( &s_hash, sig->digest_algo, encmd, enclen );
-    if( !rc && gcry_pk_sign( &s_sig, s_hash, s_skey ) )
-        rc = CDK_Gcry_Error;
+    if( !rc && (rc = gcry_pk_sign( &s_sig, s_hash, s_skey )) )
+        rc += CDK_Gcry_Error_Base;
     if( !rc )
         rc = sexp_to_sig( sig, s_sig );
     sig->digest_start[0] = md[0];
@@ -581,7 +581,7 @@
     size_t n = usage_flags;
   
     if( algo < 0 || algo > 110 )
-        return GCRYERR_INV_PK_ALGO;
+        return GPG_ERR_INV_PACKET;
     return gcry_pk_algo_info( algo, GCRYCTL_TEST_ALGO, NULL, &n );    
 }
 
@@ -690,7 +690,7 @@
                 else {
                     cdk_md_hd_t md = cdk_md_open( CDK_MD_SHA1, 1 );
                     if( !md )
-                        return CDK_Gcry_Error;
+                        return CDK_General_Error;
                     cdk_md_write( md, data, ndata - dlen );
                     cdk_md_final( md );
                     if( !memcmp( cdk_md_read( md, CDK_MD_SHA1 ),
@@ -791,14 +791,14 @@
                           sk->protect.iv, sk->protect.ivlen );
     if( !hd ) {
         cdk_free( p );
-        return CDK_Gcry_Error;
+        return CDK_General_Error;
     }
 
     md = cdk_md_open( CDK_MD_SHA1, GCRY_CIPHER_SECURE  );
     if( !md ) {
         cdk_cipher_close( hd  );
         cdk_free( p  );
-        return CDK_Gcry_Error;
+        return CDK_General_Error;
     }
     sk->protect.sha1chk = 1;
     sk->is_protected = 1;
@@ -883,7 +883,7 @@
     md = cdk_md_open( CDK_MD_SHA1, 0 );
     if( !md ) {
         _cdk_free_signature( sig );
-        return CDK_Gcry_Error;
+        return CDK_General_Error;
     }
     _cdk_hash_pubkey( sk->pk, md, 0 );
     _cdk_free_signature( sig );
@@ -921,7 +921,7 @@
     dlen = cdk_md_get_algo_dlen( md_algo );
     hd = cdk_md_open( md_algo, 0 );
     if( !hd )
-        return CDK_Gcry_Error;
+        return CDK_General_Error;
     _cdk_hash_pubkey( pk, hd, 1 );
     cdk_md_final( hd );
     memcpy( fpr, cdk_md_read( hd, md_algo ), dlen );
--- opencdk-0.5.1/src/encrypt.c.orig	2003-06-21 15:37:29.000000000 +0200
+++ opencdk-0.5.1/src/encrypt.c	2003-08-03 14:47:27.000000000 +0200
@@ -510,7 +510,7 @@
         return CDK_Inv_Algo;
     c->sig.md = cdk_md_open( c->sig.digest_algo, 0 );
     if( !c->sig.md )
-        rc = CDK_Gcry_Error;
+        rc = CDK_General_Error;
     return rc;
 }
 
--- opencdk-0.5.1/src/trustdb.c.orig	2003-06-20 21:02:10.000000000 +0200
+++ opencdk-0.5.1/src/trustdb.c	2003-08-03 14:47:45.000000000 +0200
@@ -250,7 +250,7 @@
     *r_val = CDK_TRUST_UNKNOWN;
     rmd = cdk_md_open( CDK_MD_RMD160, 0 );
     if( !rmd )
-        return CDK_Gcry_Error;
+        return CDK_General_Error;
 
     cdk_md_write( rmd, id->name, id->len );
     cdk_md_final( rmd );
--- opencdk-0.5.1/src/context.h.orig	2003-06-21 11:48:29.000000000 +0200
+++ opencdk-0.5.1/src/context.h	2003-08-03 13:23:02.000000000 +0200
@@ -37,7 +37,7 @@
 };
 
 struct cdk_sesskey_s {
-    GCRY_MPI a;
+    gcry_mpi_t a;
 };  
 
 struct cdk_verify_result_s {
--- opencdk-0.5.1/src/opencdk.h.orig	2003-06-21 16:43:23.000000000 +0200
+++ opencdk-0.5.1/src/opencdk.h	2003-08-03 14:29:45.000000000 +0200
@@ -94,7 +94,6 @@
     CDK_Inv_Packet = 4,
     CDK_Inv_Algo = 5,
     CDK_Not_Implemented = 6,
-    CDK_Gcry_Error = 7,
     CDK_Armor_Error = 8,
     CDK_Armor_CRC_Error = 9,
     CDK_MPI_Error = 10,
@@ -113,6 +112,7 @@
     CDK_Inv_Packet_Ver = 23,
     CDK_Too_Short = 24,
     CDK_Unusable_Key = 25,
+    CDK_Gcry_Error_Base = 100,
 } cdk_error_t;
 
 
