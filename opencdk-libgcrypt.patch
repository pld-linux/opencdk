--- opencdk-0.4.5/src/main.c.orig	2003-02-05 21:59:37.000000000 +0100
+++ opencdk-0.4.5/src/main.c	2003-08-03 03:23:02.000000000 +0200
@@ -74,7 +74,6 @@
     case CDK_Inv_Packet:       return "Invalid packet";
     case CDK_Inv_Algo:         return "Invalid algorithm";
     case CDK_Not_Implemented:  return "This is not implemented yet";
-    case CDK_Gcry_Error:       return gcry_strerror (gcry_errno ());
     case CDK_Armor_Error:      return "ASCII armor error";
     case CDK_Armor_CRC_Error:  return "ASCII armored damaged (CRC error)";
     case CDK_MPI_Error:        return "Invalid or missformed MPI";
@@ -92,7 +91,11 @@
     case CDK_Inv_Packet_Ver:   return "Invalid version for packet";
     case CDK_Too_Short:        return "Buffer or object is too short";
     case CDK_Unusable_Key:     return "Unusable public key";
-    default:                   sprintf (buf, "ec=%d", ec); return buf;
+    default:
+	if(ec >= CDK_Gcry_Error_Base) {
+    			       return gcry_strerror (ec - CDK_Gcry_Error_Base);
+	} else
+			       sprintf (buf, "ec=%d", ec); return buf;
     }
     return NULL;
 }
--- opencdk-0.4.5/src/verify.c.orig	2003-01-22 22:04:50.000000000 +0100
+++ opencdk-0.4.5/src/verify.c	2003-08-03 03:24:05.000000000 +0200
@@ -268,7 +268,7 @@
     GCRY_MD_HD md = NULL;
     char buf[512], chk[512];
     const char * s;
-    int rc = 0;
+    int rc = 0, temprc;
     int i, is_signed = 0, nbytes;
     int digest_algo = 0;
 
@@ -318,9 +318,9 @@
     }
     if( !digest_algo )
         digest_algo = GCRY_MD_MD5;
-    md = gcry_md_open( digest_algo, 0 );
-    if( !md ) {
-        rc = CDK_Gcry_Error;
+    temprc = gcry_md_open( &md, digest_algo, 0 );
+    if( temprc ) {
+        rc = CDK_Gcry_Error_Base + temprc;
         goto leave;
     }
 
--- opencdk-0.4.5/src/sig-check.c.orig	2003-01-30 21:29:18.000000000 +0100
+++ opencdk-0.4.5/src/sig-check.c	2003-08-03 03:24:45.000000000 +0200
@@ -237,7 +237,7 @@
     cdkPKT_signature * sig = NULL;
     CDK_KBNODE node;
     int digest_algo, is_expired = 0;
-    int rc = 0;
+    int rc = 0, temprc;
 
     if (!knode || !snode)
         return CDK_Inv_Value;
@@ -249,9 +249,9 @@
     sig = snode->pkt->pkt.signature;
     digest_algo = sig->digest_algo;
 
-    md = gcry_md_open (digest_algo, 0);
-    if (!md)
-        return CDK_Gcry_Error;
+    temprc = gcry_md_open (&md, digest_algo, 0);
+    if (temprc)
+        return CDK_Gcry_Error_Base + temprc;
 
     if (sig->sig_class == 0x20) { /* key revocation */
         _cdk_hash_pubkey (pk, md, 0);
--- opencdk-0.4.5/src/sign.c.orig	2003-02-08 22:55:10.000000000 +0100
+++ opencdk-0.4.5/src/sign.c	2003-08-03 03:26:00.000000000 +0200
@@ -408,10 +408,10 @@
 
     sk = list->key.sk;
     digest_algo = _cdk_sig_hash_for( sk->pubkey_algo, sk->version );
-    md = gcry_md_open( digest_algo, 0 );
-    if( !md ) {
+    rc = gcry_md_open( &md, digest_algo, 0 );
+    if( rc ) {
         cdk_sklist_release( list );
-        return CDK_Gcry_Error;
+        return CDK_Gcry_Error_Base + rc;
     }
 
     s = _cdk_armor_get_lineend( );
--- opencdk-0.4.5/src/keylist.c.orig	2003-01-24 08:14:03.000000000 +0100
+++ opencdk-0.4.5/src/keylist.c	2003-08-03 03:02:42.000000000 +0200
@@ -519,7 +519,7 @@
         if( sig->digest_algo != digest_algo )
             sig->digest_algo = digest_algo;
         sig->sig_class = sigclass;
-        md = gcry_md_copy( hash );
+        gcry_md_copy( &md, hash );
         _cdk_hash_sig_data( sig, md );
         gcry_md_final( md );
 
--- opencdk-0.4.5/src/seskey.c.orig	2003-01-24 19:19:37.000000000 +0100
+++ opencdk-0.4.5/src/seskey.c	2003-08-03 03:28:00.000000000 +0200
@@ -149,9 +149,9 @@
     n += dek->keylen;
     frame[n++] = chksum >> 8;
     frame[n++] = chksum;
-    rc = gcry_mpi_scan (&a, GCRYMPI_FMT_USG, frame, &nframe);
+    rc = gcry_mpi_scan (&a, GCRYMPI_FMT_USG, frame, nframe, &nframe);
     if (rc)
-        rc = CDK_Gcry_Error;
+        rc += CDK_Gcry_Error_Base;
     cdk_free (frame);
     if( !rc ) {
         rc = cdk_sesskey_new( r_esk );
@@ -178,9 +178,9 @@
         return CDK_Inv_Value;
     
     nframe = sizeof frame-1;
-    rc = gcry_mpi_print (GCRYMPI_FMT_USG, frame, &nframe, esk->a);
+    rc = gcry_mpi_print (GCRYMPI_FMT_USG, frame, nframe, &nframe, esk->a);
     if (rc)
-        return CDK_Gcry_Error;
+        return CDK_Gcry_Error_Base + rc;
     dek = cdk_salloc (sizeof *dek, 1);
     if (!dek)
         return CDK_Out_Of_Core;
@@ -253,13 +253,13 @@
 
         rc = md_get_asnoid (digest_algo, NULL, &asnlen);
         if (rc || !asnlen)
-            return CDK_Gcry_Error;
+            return CDK_Gcry_Error_Base + rc;
         asn = cdk_malloc (asnlen + 1);
         if (!asn)
             return CDK_Out_Of_Core;
         rc = md_get_asnoid (digest_algo, asn, &asnlen);
         if (rc)
-            return CDK_Gcry_Error;
+            return CDK_Gcry_Error_Base + rc;
         rc = do_encode_md (r_md, r_mdlen, md, digest_algo, digest_size,
                            nbits, asn, asnlen);
         cdk_free (asn);
@@ -397,7 +397,7 @@
 cdk_dek_set_key( CDK_DEK dek, const byte * key, size_t keylen )
 {
     GCRY_CIPHER_HD hd;
-    int i;
+    int i, rc;
 
     if( !dek )
         return CDK_Inv_Value;
@@ -405,9 +405,9 @@
         return CDK_Inv_Value;
 
     if( !key && !keylen ) {
-        hd = gcry_cipher_open( dek->algo, GCRY_CIPHER_MODE_CFB, 1 );
+        rc = gcry_cipher_open( &hd, dek->algo, GCRY_CIPHER_MODE_CFB, 1 );
         if( !hd )
-            return CDK_Gcry_Error;
+            return CDK_Gcry_Error_Base + rc;
         gcry_randomize( dek->key, dek->keylen, GCRY_STRONG_RANDOM );
         for( i = 0; i < 8; i++ ) {
             if( !gcry_cipher_setkey( hd, dek->key, dek->keylen ) ) {
@@ -444,7 +444,7 @@
 hash_passphrase (CDK_DEK dek, const char * pw, CDK_S2K_HD s2k, int create)
 {
     GCRY_MD_HD md;
-    int pass, i;
+    int pass, i, rc;
     int used = 0, pwlen = 0;
 
     if (!dek || !pw || !s2k)
@@ -455,9 +455,9 @@
     pwlen = strlen (pw);
 
     dek->keylen = gcry_cipher_get_algo_keylen (dek->algo);
-    md = gcry_md_open (s2k->hash_algo, GCRY_MD_FLAG_SECURE);
-    if (!md)
-        return CDK_Gcry_Error;
+    rc = gcry_md_open (&md, s2k->hash_algo, GCRY_MD_FLAG_SECURE);
+    if (rc)
+        return CDK_Gcry_Error_Base + rc;
 
     for (pass = 0; used < dek->keylen; pass++) {
         if (pass) {
--- opencdk-0.4.5/src/pubkey.c.orig	2003-02-08 22:57:57.000000000 +0100
+++ opencdk-0.4.5/src/pubkey.c	2003-08-03 03:37:54.000000000 +0200
@@ -43,8 +43,8 @@
         return NULL;
     for( i = 0; i < ncount; i++ ) {
         nbytes = m[i]->bytes + 2;
-        if( gcry_mpi_scan( &d[i], GCRYMPI_FMT_PGP, m[i]->data, &nbytes ) ) {
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_mpi_scan( &d[i], GCRYMPI_FMT_PGP, m[i]->data, nbytes, &nbytes )) ) {
+            rc += CDK_Gcry_Error_Base;
             break;
 	}
     }
@@ -80,21 +80,21 @@
         rc = CDK_MPI_Error;
     if( !rc && is_RSA( sk->pubkey_algo ) ) {
         fmt = "(private-key(openpgp-rsa(n%m)(e%m)(d%m)(p%m)(q%m)(u%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, mpk[0], mpk[1],
-                             msk[0], msk[1], msk[2], msk[3] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, mpk[0], mpk[1],
+                                   msk[0], msk[1], msk[2], msk[3] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else if( !rc && is_ELG( sk->pubkey_algo ) ) {
         fmt = "(private-key(openpgp-elg(p%m)(g%m)(y%m)(x%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, mpk[0], mpk[1],
-                             mpk[2], msk[0] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, mpk[0], mpk[1],
+                                   mpk[2], msk[0] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else if( !rc && is_DSA( sk->pubkey_algo ) ) {
         fmt = "(private-key(openpgp-dsa(p%m)(q%m)(g%m)(y%m)(x%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, mpk[0], mpk[1], mpk[2],
-                             mpk[3], msk[0] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, mpk[0], mpk[1], mpk[2],
+                                   mpk[3], msk[0] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else
         rc = CDK_Inv_Algo;
@@ -124,18 +124,18 @@
         return CDK_MPI_Error;
     if( is_RSA( pk->pubkey_algo ) ) {
         fmt = "(public-key(openpgp-rsa(n%m)(e%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else if( is_ELG( pk->pubkey_algo ) ) {
         fmt = "(public-key(openpgp-elg(p%m)(g%m)(y%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1], m[2] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1], m[2] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else if( is_DSA( pk->pubkey_algo ) ) {
         fmt = "(public-key(openpgp-dsa(p%m)(q%m)(g%m)(y%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1], m[2], m[3] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1], m[2], m[3] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else
         rc = CDK_Inv_Algo;
@@ -153,8 +153,8 @@
 
     if( !r_sexp || !esk )
         return CDK_Inv_Value;
-    if( gcry_sexp_build( &sexp, NULL, "%m", esk ) )
-        rc = CDK_Gcry_Error;
+    if( (rc = gcry_sexp_build( &sexp, NULL, "%m", esk )) )
+        rc += CDK_Gcry_Error_Base;
     *r_sexp = sexp;
     return rc;
 }
@@ -173,10 +173,10 @@
     nbytes = mdlen ? mdlen : gcry_md_get_algo_dlen( algo );
     if( !nbytes )
         return CDK_Inv_Algo;
-    if( gcry_mpi_scan( &m, GCRYMPI_FMT_USG, md, &nbytes ) )
-        return CDK_Gcry_Error;
-    if( gcry_sexp_build( &sexp, NULL, "%m", m ) )
-        rc = CDK_Gcry_Error;
+    if( (rc = gcry_mpi_scan( &m, GCRYMPI_FMT_USG, md, nbytes, &nbytes )) )
+        return CDK_Gcry_Error_Base + rc;
+    if( (rc = gcry_sexp_build( &sexp, NULL, "%m", m )) )
+        rc += CDK_Gcry_Error_Base;
     if( !rc )
         *r_md = sexp;
     gcry_mpi_release( m );
@@ -198,11 +198,11 @@
 
     list = gcry_sexp_find_token( sexp, val, 0 );
     if( !list )
-        return CDK_Gcry_Error;
+        return CDK_Gcry_Error_Base;
     m = gcry_sexp_nth_mpi( list, 1, 0 );
     if( !m ) {
         gcry_sexp_release( list );
-        return CDK_Gcry_Error;
+        return CDK_Gcry_Error_Base;
     }
     nbits = gcry_mpi_get_nbits( m );
     nbytes = (nbits + 7) / 8;
@@ -213,11 +213,11 @@
     }
     buf->data[0] = nbits >> 8;
     buf->data[1] = nbits;
-    if( gcry_mpi_print( GCRYMPI_FMT_USG, NULL, &nbytes, m ) )
-        rc = CDK_Gcry_Error;
+    if( (rc = gcry_mpi_print( GCRYMPI_FMT_USG, NULL, nbytes, &nbytes, m )) )
+        rc += CDK_Gcry_Error_Base;
     else
-        if( gcry_mpi_print( GCRYMPI_FMT_USG, buf->data + 2, &nbytes, m ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_mpi_print( GCRYMPI_FMT_USG, buf->data + 2, nbytes, &nbytes, m )) )
+            rc += CDK_Gcry_Error_Base;
     if( !rc ) {
         buf->bytes = nbytes;
         buf->bits = nbits;
@@ -269,18 +269,18 @@
         return CDK_MPI_Error;
     if( is_RSA( sig->pubkey_algo ) ) {
         fmt = "(sig-val(openpgp-rsa(s%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, m[0] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, m[0] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else if( is_ELG( sig->pubkey_algo ) ) {
         fmt = "(sig-val(openpgp-elg(r%m)(s%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else if( is_DSA( sig->pubkey_algo ) ) {
         fmt = "(sig-val(openpgp-dsa(r%m)(s%m)))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else
         rc = CDK_Inv_Algo;
@@ -328,13 +328,13 @@
         return CDK_MPI_Error;
     if( is_RSA( enc->pubkey_algo ) ) {
         fmt = "(enc-val(openpgp-rsa((a%m))))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, m[0] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, m[0] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else if( is_ELG( enc->pubkey_algo ) ) {
         fmt = "(enc-val(openpgp-elg((a%m)(b%m))))";
-        if( gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1] ) )
-            rc = CDK_Gcry_Error;
+        if( (rc = gcry_sexp_build( &sexp, NULL, fmt, m[0], m[1] )) )
+            rc += CDK_Gcry_Error_Base;
     }
     else
         rc = CDK_Inv_Algo;
@@ -414,8 +414,8 @@
     rc = seckey_to_sexp( &s_skey, sk );
     if( !rc )
         rc = pubenc_to_sexp( &s_data, pke );
-    if( !rc && gcry_pk_decrypt( &s_plain, s_data, s_skey ) )
-        rc = CDK_Gcry_Error;
+    if( !rc && (rc = gcry_pk_decrypt( &s_plain, s_data, s_skey )) )
+        rc += CDK_Gcry_Error_Base;
     if( !rc ) {
         rc = cdk_sesskey_new( r_sk );
         if( !rc )
@@ -461,8 +461,8 @@
         rc = seckey_to_sexp( &s_skey, sk );
     if( !rc )
         rc = digest_to_sexp( &s_hash, sig->digest_algo, encmd, enclen );
-    if( !rc && gcry_pk_sign( &s_sig, s_hash, s_skey ) )
-        rc = CDK_Gcry_Error;
+    if( !rc && (rc = gcry_pk_sign( &s_sig, s_hash, s_skey )) )
+        rc += CDK_Gcry_Error_Base;
     if( !rc )
         rc = sexp_to_sig( sig, s_sig );
     sig->digest_start[0] = md[0];
@@ -580,7 +580,7 @@
     size_t n = usage_flags;
   
     if( algo < 0 || algo > 110 )
-        return GCRYERR_INV_PK_ALGO;
+        return GPG_ERR_INV_PACKET;
     return gcry_pk_algo_info( algo, GCRYCTL_TEST_ALGO, NULL, &n );    
 }
 
@@ -647,7 +647,7 @@
     int flags = GCRY_CIPHER_SECURE | GCRY_CIPHER_ENABLE_SYNC;
     int rc = 0;
     
-    hd = gcry_cipher_open( algo, GCRY_CIPHER_MODE_CFB, flags );
+    gcry_cipher_open( &hd, algo, GCRY_CIPHER_MODE_CFB, flags );
     if( hd ) {
         rc = gcry_cipher_setkey( hd, key, keylen  );
         if( !rc )
@@ -686,7 +686,7 @@
                           sk->protect.iv, sk->protect.ivlen );
         if( !hd ) {
             cdk_free( dek );
-            return CDK_Gcry_Error;
+            return CDK_Gcry_Error_Base;
         }
         wipemem( dek, sizeof dek );
         cdk_dek_free( dek );
@@ -708,9 +708,10 @@
                     return CDK_Inv_Packet;
                 }
                 else {
-                    GCRY_MD_HD md = gcry_md_open( GCRY_MD_SHA1, 1 );
-                    if( !md )
-                        return CDK_Gcry_Error;
+                    GCRY_MD_HD md;
+		    rc = gcry_md_open( &md, GCRY_MD_SHA1, 1 );
+                    if( rc )
+                        return CDK_Gcry_Error_Base + rc;
                     gcry_md_write( md, data, ndata - dlen );
                     gcry_md_final( md );
                     if( !memcmp( gcry_md_read( md, GCRY_MD_SHA1 ),
@@ -810,14 +811,14 @@
                       sk->protect.iv, sk->protect.ivlen );
     if( !hd ) {
         cdk_free( p );
-        return CDK_Gcry_Error;
+        return CDK_Gcry_Error_Base;
     }
 
-    md = gcry_md_open( CDK_MD_SHA1, GCRY_CIPHER_SECURE  );
-    if( !md ) {
+    rc = gcry_md_open( &md, CDK_MD_SHA1, GCRY_CIPHER_SECURE  );
+    if( rc ) {
         gcry_cipher_close( hd  );
         cdk_free( p  );
-        return CDK_Gcry_Error;
+        return CDK_Gcry_Error_Base + rc;
     }
     sk->protect.sha1chk = 1;
     sk->is_protected = 1;
@@ -866,7 +867,7 @@
     cdkPKT_signature * sig;
     CDK_SUBPKT node;
     char * p = NULL, * dat;
-    int n;
+    int n, rc;
     
     if( !sk || !ret_revcert )
         return CDK_Inv_Value;
@@ -899,10 +900,10 @@
     }
     cdk_free( dat );
 
-    md = gcry_md_open( GCRY_MD_SHA1, 0 );
-    if( !md ) {
+    rc = gcry_md_open( &md, GCRY_MD_SHA1, 0 );
+    if( rc ) {
         _cdk_free_signature( sig );
-        return CDK_Gcry_Error;
+        return CDK_Gcry_Error_Base + rc;
     }
     _cdk_hash_pubkey( sk->pk, md, 1 );
     _cdk_free_signature( sig );
@@ -928,7 +929,7 @@
 {
     GCRY_MD_HD hd;
     int md_algo;
-    int dlen = 0;
+    int dlen = 0, rc;
 
     if( !pk || !fpr )
         return CDK_Inv_Value;
@@ -938,9 +939,9 @@
     else
         md_algo = pk->version < 4 ? CDK_MD_RMD160 : CDK_MD_SHA1;
     dlen = gcry_md_get_algo_dlen( md_algo );
-    hd = gcry_md_open( md_algo, 0 );
-    if( !hd )
-        return CDK_Gcry_Error;
+    rc = gcry_md_open( &hd, md_algo, 0 );
+    if( rc )
+        return CDK_Gcry_Error_Base + rc;
     _cdk_hash_pubkey( pk, hd, 1 );
     gcry_md_final( hd );
     memcpy( fpr, gcry_md_read( hd, md_algo ), dlen );
--- opencdk-0.4.5/src/encrypt.c.orig	2003-02-08 12:31:53.000000000 +0100
+++ opencdk-0.4.5/src/encrypt.c	2003-08-03 03:38:33.000000000 +0200
@@ -349,7 +349,7 @@
     cdk_stream_read( s, NULL, 0 );
     mfx = _cdk_stream_get_opaque( s, fHASH );
     if( mfx && mfx->md )
-        *r_md = gcry_md_copy( mfx->md );
+        gcry_md_copy( r_md, mfx->md );
     cdk_stream_close( s );
     return 0;
 }
@@ -519,9 +519,9 @@
     c->sig.digest_algo = pkt->pkt.onepass_sig->digest_algo;
     if( _cdk_md_test_algo( c->sig.digest_algo ) )
         return CDK_Inv_Algo;
-    c->sig.md = gcry_md_open( c->sig.digest_algo, 0 );
-    if( !c->sig.md )
-        rc = CDK_Gcry_Error;
+    rc = gcry_md_open( &c->sig.md, c->sig.digest_algo, 0 );
+    if( rc )
+        rc += CDK_Gcry_Error_Base;
     return rc;
 }
 
--- opencdk-0.4.5/src/trustdb.c.orig	2003-01-24 19:16:59.000000000 +0100
+++ opencdk-0.4.5/src/trustdb.c	2003-08-03 03:38:55.000000000 +0200
@@ -246,9 +246,9 @@
         return rc;
   
     *r_val = CDK_TRUST_UNKNOWN;
-    rmd = gcry_md_open( GCRY_MD_RMD160, 0 );
-    if( !rmd )
-        return CDK_Gcry_Error;
+    rc = gcry_md_open( &rmd, GCRY_MD_RMD160, 0 );
+    if( rc )
+        return CDK_Gcry_Error_Base + rc;
 
     gcry_md_write( rmd, id->name, id->len );
     gcry_md_final( rmd );
--- opencdk-0.4.5/src/cipher.c.orig	2003-02-08 23:02:04.000000000 +0100
+++ opencdk-0.4.5/src/cipher.c	2003-08-03 03:40:39.000000000 +0200
@@ -59,7 +59,7 @@
 {
     md_filter_s * mfx = opaque;
     byte buf[8192];
-    int nread;
+    int nread, rc;
 
     if( !mfx )
         return CDK_Inv_Value;
@@ -67,9 +67,9 @@
     _cdk_log_debug( "hash filter: encode (algo=%d)\n", mfx->digest_algo );
     
     if( !mfx->md ) {
-        mfx->md = gcry_md_open( mfx->digest_algo, 0 );
-        if( !mfx->md )
-            return CDK_Gcry_Error;
+        rc = gcry_md_open( &mfx->md, mfx->digest_algo, 0 );
+        if( rc )
+            return CDK_Gcry_Error_Base + rc;
     }
   
     while( !feof( in ) ) {
@@ -112,13 +112,13 @@
     
     if( syncflag )
         flags |= GCRY_CIPHER_ENABLE_SYNC;
-    *r_hd = gcry_cipher_open( algo, GCRY_CIPHER_MODE_CFB, flags );
-    if( !*r_hd )
-        return CDK_Gcry_Error;
+    rc = gcry_cipher_open( r_hd, algo, GCRY_CIPHER_MODE_CFB, flags );
+    if( rc )
+        return CDK_Gcry_Error_Base + rc;
     rc = gcry_cipher_setkey( *r_hd, key, keylen );
     if( !rc )
         rc = gcry_cipher_setiv( *r_hd, iv, ivlen );
-    return rc? CDK_Gcry_Error : 0;
+    return rc? (CDK_Gcry_Error_Base + rc) : 0;
 }
 
 
@@ -152,9 +152,9 @@
     
     if( use_mdc ) {
         ed.mdc_method = CDK_MD_SHA1;
-        cfx->mdc = gcry_md_open( CDK_MD_SHA1, 0 );
-        if( !cfx->mdc )
-            return CDK_Gcry_Error;
+        rc = gcry_md_open( &cfx->mdc, CDK_MD_SHA1, 0 );
+        if( rc )
+            return CDK_Gcry_Error_Base + rc;
     }
 
     cdk_pkt_init( &pkt );
@@ -264,7 +264,7 @@
             gcry_md_write( cfx->mdc, buf, nread );
         rc = gcry_cipher_encrypt( cfx->hd, buf, nread, NULL, 0 );
         if( rc ) {
-            rc = CDK_Gcry_Error;
+            rc += CDK_Gcry_Error_Base;
             break;
         }
         nbytes -= nread;
@@ -303,7 +303,7 @@
             gcry_md_write( cfx->mdc, buf, nread );
         rc = gcry_cipher_encrypt( cfx->hd, buf, nread, NULL, 0 );
         if( rc ) {
-            rc = CDK_Gcry_Error;
+            rc += CDK_Gcry_Error_Base;
             break;
         }
         if( progress_cb )
@@ -337,9 +337,9 @@
     if( cfx->datalen && cfx->datalen < (nprefix + 2) )
         return CDK_Inv_Value;
     if( cfx->mdc_method ) {
-        cfx->mdc = gcry_md_open( cfx->mdc_method, 0 );
-        if( !cfx->mdc )
-            return CDK_Gcry_Error;
+        rc = gcry_md_open( &cfx->mdc, cfx->mdc_method, 0 );
+        if( rc )
+            return CDK_Gcry_Error_Base + rc;
     }
     rc = gcry_cipher_new( &cfx->hd, dek->algo, dek->key, dek->keylen,
                           NULL, 0, cfx->mdc_method == 0? 1 : 0 );
@@ -406,7 +406,7 @@
             break;
         rc = gcry_cipher_decrypt( cfx->hd, buf, nread, NULL, 0 );
         if( rc ) {
-            rc = CDK_Gcry_Error;
+            rc += CDK_Gcry_Error_Base;
             break;
         }
         if( feof( in ) && cfx->mdc )
--- opencdk-0.4.5/src/keygen.c.orig	2003-02-05 21:34:24.000000000 +0100
+++ opencdk-0.4.5/src/keygen.c	2003-08-03 03:41:10.000000000 +0200
@@ -278,7 +278,7 @@
     if( list )
         *r_resarr = gcry_sexp_nth_mpi( list, 1, 0 );
     gcry_sexp_release( list );
-    return list? 0 : CDK_Gcry_Error;
+    return list? 0 : CDK_Gcry_Error_Base;
 }
 
   
@@ -446,7 +446,7 @@
         nbytes = a->bytes;
         a->data[0] = nbits >> 8;
         a->data[1] = nbits;
-        rc = gcry_mpi_print( GCRYMPI_FMT_USG, a->data+2, &nbytes, resarr[i] );
+        rc = gcry_mpi_print( GCRYMPI_FMT_USG, a->data+2, nbytes, &nbytes, resarr[i] );
         if( rc )
             break;
         if( pk )
@@ -554,7 +554,7 @@
         _cdk_subpkt_add( sig->hashed, node );
     }
   
-    md = gcry_md_open( sig->digest_algo, 0 );
+    gcry_md_open( &md, sig->digest_algo, 0 );
     if( !md ) {
         _cdk_free_signature( sig );
         return NULL;
@@ -646,7 +646,7 @@
         _cdk_subpkt_init( node, SIGSUBPKT_ISSUER,  buf, 8 );
     }
 
-    md = gcry_md_open( sig->digest_algo, 0 );
+    gcry_md_open( &md, sig->digest_algo, 0 );
     if( !md ) {
         _cdk_free_signature( sig );
         return NULL;
--- opencdk-0.4.5/src/opencdk.h.orig	2003-02-10 21:50:23.000000000 +0100
+++ opencdk-0.4.5/src/opencdk.h	2003-08-03 03:21:20.000000000 +0200
@@ -83,7 +83,6 @@
   CDK_Inv_Packet = 4,
   CDK_Inv_Algo = 5,
   CDK_Not_Implemented = 6,
-  CDK_Gcry_Error = 7,
   CDK_Armor_Error = 8,
   CDK_Armor_CRC_Error = 9,
   CDK_MPI_Error = 10,
@@ -102,6 +101,7 @@
   CDK_Inv_Packet_Ver = 23,
   CDK_Too_Short = 24,
   CDK_Unusable_Key = 25,
+  CDK_Gcry_Error_Base = 100,
 } cdk_error_t;
 
 
